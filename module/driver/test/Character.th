//
// Copyright 2013 (C). Alex Robenko. All rights reserved.
//

// This file is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <boost/asio.hpp>
#include <boost/date_time.hpp>

#include "embxx/util/EventLoop.h"
#include "embxx/driver/Character.h"
#include "cxxtest/TestSuite.h"

#include "module/device/test/EventLoopLock.h"
#include "module/device/test/EventLoopCond.h"
#include "module/device/test/UartDevice.h"

class CharacterDriverTestSuite : public CxxTest::TestSuite
{
public:
    void test1();
    void test2();
    void test3();
    void test4();

private:
    typedef embxx::util::EventLoop<
        512,
        embxx::device::test::EventLoopLock,
        embxx::device::test::EventLoopCond> EventLoop;

    typedef embxx::device::test::UartDevice<EventLoop::LockType, char> CharDevice;
};

void CharacterDriverTestSuite::test1()
{
    typedef embxx::driver::Character<CharDevice, EventLoop> Socket;
    EventLoop el;
    CharDevice device(el.getLock());
    Socket socket(device, el);

    static const std::string ReadString(
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz");

    char outArray[256] = {};
    device.setDataToRead(&ReadString[0], ReadString.size());

    bool asyncReadHandlerCalled = false;
    socket.asyncRead(outArray, ReadString.size(),
        [&el, &outArray, &asyncReadHandlerCalled](const embxx::error::ErrorStatus& es, std::size_t size)
        {
            TS_ASSERT(!es);
            asyncReadHandlerCalled = true;
            TS_ASSERT_EQUALS(size, ReadString.size());
            TS_ASSERT(std::equal(ReadString.begin(), ReadString.end(), &outArray[0]));
            el.stop();
        });

    el.run();
    TS_ASSERT_EQUALS(asyncReadHandlerCalled, true);
}

void CharacterDriverTestSuite::test2()
{
    typedef embxx::driver::Character<CharDevice, EventLoop> Socket;
    EventLoop el;
    CharDevice device(el.getLock());
    Socket socket(device, el);

    static const std::string WriteString(
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz");

    bool asyncWriteHandlerCalled = false;
    socket.asyncWrite(&WriteString[0], WriteString.size(),
        [&el, &device, &asyncWriteHandlerCalled](const embxx::error::ErrorStatus& es, std::size_t size)
        {
            TS_ASSERT(!es);
            asyncWriteHandlerCalled = true;
            TS_ASSERT_EQUALS(size, WriteString.size());
            el.stop();
        });

    el.run();
    TS_ASSERT_EQUALS(asyncWriteHandlerCalled, true);
    TS_ASSERT(std::equal(WriteString.begin(), WriteString.end(), device.getWrittenData().begin()));
}

void CharacterDriverTestSuite::test3()
{
    typedef embxx::driver::Character<CharDevice, EventLoop> Socket;
    EventLoop el;
    CharDevice device(el.getLock());
    Socket socket(device, el);

    static const std::string ReadString(
        "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz");

    char outArray[256] = {};
    device.setDataToRead(&ReadString[0], ReadString.size());

    bool asyncReadHandlerCalled = false;
    socket.asyncReadUntil(outArray, ReadString.size(), '\n',
        [&el, &outArray, &asyncReadHandlerCalled](const embxx::error::ErrorStatus& es, std::size_t size)
        {
            TS_ASSERT(!es);
            asyncReadHandlerCalled = true;
            TS_ASSERT_EQUALS(size, 6U);
            TS_ASSERT(std::equal(ReadString.begin(), ReadString.begin() + 6U, &outArray[0]));
            el.stop();
        });

    el.run();
    TS_ASSERT_EQUALS(asyncReadHandlerCalled, true);
}

void CharacterDriverTestSuite::test4()
{
    typedef embxx::driver::Character<
        CharDevice,
        EventLoop,
        embxx::util::StaticFunction<void(const embxx::error::ErrorStatus& es, std::size_t), 20> > Socket;
    EventLoop el;
    CharDevice device(el.getLock());
    Socket socket(device, el);

    static const std::string CommonString(
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz");

    char outArray[256] = {};
    device.setDataToRead(&CommonString[0], CommonString.size());

    bool asyncReadHandlerCalled = false;
    bool asyncWriteHandlerCalled = false;
    socket.asyncRead(outArray, CommonString.size(),
        [&el, &outArray, &asyncReadHandlerCalled, &asyncWriteHandlerCalled](const embxx::error::ErrorStatus& es, std::size_t size)
        {
            TS_ASSERT(!es);
            asyncReadHandlerCalled = true;
            TS_ASSERT_EQUALS(size, CommonString.size());
            TS_ASSERT(std::equal(CommonString.begin(), CommonString.end(), &outArray[0]));
            if (asyncWriteHandlerCalled) {
                el.stop();
            }
        });

    socket.asyncWrite(&CommonString[0], CommonString.size(),
        [&el, &asyncReadHandlerCalled, &asyncWriteHandlerCalled](const embxx::error::ErrorStatus& es, std::size_t writtenSize)
        {
            TS_ASSERT(!es);
            asyncWriteHandlerCalled = true;
            TS_ASSERT_EQUALS(writtenSize, CommonString.size());
            if (asyncReadHandlerCalled) {
                el.stop();
            }
        });

    el.run();
    TS_ASSERT_EQUALS(asyncReadHandlerCalled, true);
    TS_ASSERT_EQUALS(asyncWriteHandlerCalled, true);
    TS_ASSERT(std::equal(CommonString.begin(), CommonString.end(), device.getWrittenData().begin()));
}
