/// @page driver_character_page Character device driver
/// @section driver_character_overview Overview
/// Character device driver (embxx::driver::Character) provides a convenient
/// interface for I/O operations over hardware device (peripheral) that
/// supports only single character transmition/reception at a time. 
/// 
/// The operations the driver currently supports are:
/// @li Read number of characters into the buffer.
/// @li Read characters into the buffer until particular character is received.
/// @li Write number of characters from the buffer.
/// @li Cancel current "read" operation.
/// @li Cancel current "write" operation.
///
/// @section driver_character_tutorial How to use
/// Like any other driver in embxx::driver module embxx::driver::Character 
/// depends on and uses an event loop (a variant of embxx::util::EventLoop) to
/// schedule execution of "read/write complete" handlers. To be able to define 
/// a character driver object it is needed to define and instantiate EventLoop one.
/// @code
/// #include "embxx/util/EventLoop.h"
/// typedef embxx::util::EventLoop<...> EventLoop;
/// EventLoop el;
/// @endcode
///
/// embxx::driver::Character also requires device (peripheral) control class to
/// define following interface:
/// @code
/// class CharDevice
/// {
/// public:
///     // Define each character type as CharType
///     typedef char CharType;
///
///     // Set the "can read" interrupt callback which has "void ()"
///     // signature. The callback must be called when there is at least
///     // one byte available. The callback will perform multiple canRead()
///     // and read() calls until canRead() returns false. This function is
///     // called in NON-interrupt (event loop) context when the driver
///     // object is constructed, but the callback itself is expected to
///     // be called by the device control object in interrupt context.
///     template <typename TFunc>
///     void setCanReadHandler(TFunc&& func) { ... }
///
///     // Set the "can write" interrupt callback which has "void ()"
///     // signature. The callback must be called when there is a space for
///     // at least one byte to be written. The callback will perform multiple
///     // canWrite() and write() calls until canWrite() returns false. This
///     // function is called in NON-interrupt (event loop) context when
///     // the driver object is constructed, but the callback itself is
///     // expected to be called by the device control object in interrupt
///     // context.
///     template <typename TFunc>
///     void setCanReadHandler(TFunc&& func) { ... }
///
///     // Set the "read complete" interrupt callback which has
///     // "void (const embxx::error::ErrorStatus&)" signature. The callback
///     // must be called when read operation is complete (either successfully
///     // or with errors) and read interrupts are disabled, i.e. no more
///     // "can read" callback calls will follow until next call to startRead().
///     // The error status passed as a parameter must indicate the status
///     // of the read operation. This function is called in NON-interrupt
///     // (event loop) context, but the callback itself is expected
///     // to be called by the device control object in interrupt context.
///     template <typename TFunc>
///     void setReadCompleteHandler(TFunc&& func) { ... }
///
///     // Set the "write complete" interrupt callback which has
///     // "void (const embxx::error::ErrorStatus&)" signature. The callback
///     // must be called when write operation is complete (either successfully
///     // or with errors) and write interrupts are disabled, i.e. no more
///     // "can write" callback calls will follow until next call to startWrite().
///     // The error status passed as a parameter must indicate the status
///     // of the write operation. This function is called in NON-interrupt
///     // (event loop) context, but the callback itself is expected
///     // to be called by the device control object in interrupt context.
///     template <typename TFunc>
///     void setWriteCompleteHandler(TFunc&& func) { ... }
///
///     // Start read operation. The device will perform some configuration
///     // if needed and enable read interrupts, i.e. interrupt when there
///     // is at least one character to read. The "context" is a dummy
///     // parameter that indicates whether the function is executed in
///     // NON-interrupt (event loop) or interrupt contexts. The function
///     // is called only in event loop context.
///     void startRead(std::size_t length, embxx::device::context::EventLoop context) { ... }
///
///     // Cancel read operation. The return value indicates whether the
///     // read operation was cancelled. The "context" is a dummy
///     // parameter that indicates whether the function is executed in
///     // NON-interrupt (event loop) or interrupt contexts. The read
///     // canellation in interrupt context may happen only when readUntil()
///     // request is used.
///     bool cancelRead(embxx::device::context::EventLoop context) { ... }
///     bool cancelRead(embxx::device::context::Interrupt context) { ... }
///
///     // Start write operation. The device will perform some configuration
///     // if needed and enable write interrupts, i.e. interrupt when there
///     // is space for at least one character to be written. The "context"
///     // is a dummy parameter that indicates whether the function is
///     // executed in NON-interrupt (event loop) or interrupt contexts.
///     // The function is called only in event loop context.
///     void startWrite(std::size_t length, embxx::device::context::EventLoop context) { ... }
///
///     // Cancel write operation. The return value indicates whether the
///     // read operation was cancelled. The "context" is a dummy
///     // parameter that indicates whether the function is executed in
///     // NON-interrupt (event loop) or interrupt contexts.
///     // The function is called only in event loop context.
///     bool cancelWrite(embxx::device::context::EventLoop context) { ... }
///
///     // Inquiry whether there is at least one character to be
///     // read. Will be called in the interrupt context. May be called
///     // multiple times in the same interrupt.
///     bool canRead(embxx::device::context::Interrupt context) { ... }
///
///     // Inquiry whether there is a space for at least one character to
///     // be written. Will be called in the interrupt context. May be called
///     // multiple times in the same interrupt.
///     bool canWrite(embxx::device::context::Interrupt context) { ... }
///
///     // Read one character. Precondition to this call: canRead() returns
///     // true. Will be called in the interrupt context. May be called
///     // multiple times in the same interrupt.
///     CharType read(embxx::device::context::Interrupt context) { ... }
///
///     // Write one character. Precondition to this call: canWrite() returns
///     // true. Will be called in the interrupt context. May be called
///     // multiple times in the same interrupt.
///     void write(CharType value, embxx::device::context::Interrupt context) { ... }
/// private:
///     ...
/// };
/// 
/// CharDevice device;
/// @endcode
///
/// Define and instantiate Character driver as following:
/// @code
/// #include "embxx/driver/Character.h"
/// 
/// // The third and fourth template parameters are default ones
/// typedef embxx::driver::Character<EventLoop, CharDevice> CharDriver;
/// CharDriver driver(device, el);
/// @endcode 
/// Now it is possible to issue asynchronous read/write requests for the blocks
/// of data. Please note, that it is impossible to issue second read or write
/// request while previous one of the same type hasn't finished (the provided  
/// callback wasn't executed). However it is possible to issue independed read 
/// and write requests at the same time (but only in case the actual device
/// control object allows it).
///
/// Read block of characters examle:
/// @code
/// CharDriver::CharType buf[128];
/// driver.asyncRead(buf, sizeof(buf)/sizeof(buf[0]), 
///     [](const embxx::error::ErrorStatus& status, std::size_t bytesRead)
///     {
///         ... // Handle read data in this callback.
///     });
/// @endcode
///
/// Read block of characters until specific character is received:
/// @code
/// CharDriver::CharType buf[128];
/// driver.asyncReadUntil(buf, sizeof(buf)/sizeof(buf[0]), '\n' 
///     [](const embxx::error::ErrorStatus& status, std::size_t bytesRead)
///     {
///         ... // Handle read data in this callback.
///     });
/// @endcode
///
/// Write block of characters example:
/// @code
/// CharDriver::CharType buf[128] = {...};
/// driver.asyncWrite(buf, sizeof(buf)/sizeof(buf[0]),
///     [](const embxx::error::ErrorStatus&, std::size_t bytesWritten)
///     {
///         ... // Perform operations after the write is complete in this callback.
///     });
/// @endcode
